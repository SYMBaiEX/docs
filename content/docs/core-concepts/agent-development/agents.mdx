---
title: "Agents"
description: "Understanding the Agent and Character interfaces, runtime integration, and agent lifecycle management in ElizaOS"
---

# Agents

Agents are the core operational units in ElizaOS, representing autonomous entities that can interact with users and systems. This page covers the fundamental concepts of agents, their structure, and how they relate to characters.

## Core Concepts

### Agent vs Character

In ElizaOS, there's an important distinction between **Character** and **Agent**:

- **Character**: A static definition that describes an agent's personality, capabilities, and configuration
- **Agent**: A runtime instance that extends a Character with operational status, timestamps, and database management

```typescript
// Character - Static definition
interface Character {
  id?: UUID;
  name: string;
  username?: string;
  bio: string | string[];
  // ... personality and configuration
}

// Agent - Runtime instance
interface Agent extends Character {
  enabled?: boolean;
  status?: AgentStatus;
  createdAt: number;
  updatedAt: number;
}
```

### Agent Status

Agents have operational states managed through the `AgentStatus` enum:

```typescript
export enum AgentStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
}
```

## Agent Interface

The complete Agent interface extends Character with runtime management fields:

```typescript
interface Agent extends Character {
  /** Whether the agent is enabled for operation */
  enabled?: boolean;
  
  /** Current operational status */
  status?: AgentStatus;
  
  /** Timestamp when agent was created in database */
  createdAt: number;
  
  /** Timestamp when agent was last updated */
  updatedAt: number;
}
```

### Key Properties

- **enabled**: Boolean flag controlling whether the agent can operate
- **status**: Current operational state (ACTIVE or INACTIVE)
- **createdAt**: Database creation timestamp
- **updatedAt**: Last modification timestamp

## Character Definition

An Agent's personality and behavior are defined through the Character interface:

```typescript
interface Character {
  /** Optional unique identifier */
  id?: UUID;
  
  /** Character name */
  name: string;
  
  /** Optional username for interactions */
  username?: string;
  
  /** System prompt guiding behavior */
  system?: string;
  
  /** Prompt templates for different situations */
  templates?: {
    [key: string]: TemplateType;
  };
  
  /** Character biography */
  bio: string | string[];
  
  /** Example conversations */
  messageExamples?: MessageExample[][];
  
  /** Example posts */
  postExamples?: string[];
  
  /** Topics of interest */
  topics?: string[];
  
  /** Character traits */
  adjectives?: string[];
  
  /** Knowledge base paths */
  knowledge?: (string | { path: string; shared?: boolean } | DirectoryItem)[];
  
  /** Available plugins */
  plugins?: string[];
  
  /** Configuration settings */
  settings?: {
    [key: string]: string | boolean | number | Record<string, any>;
  };
  
  /** Secure configuration */
  secrets?: {
    [key: string]: string | boolean | number;
  };
  
  /** Writing style guides */
  style?: {
    all?: string[];
    chat?: string[];
    post?: string[];
  };
}
```

## Agent Runtime Integration

Agents are managed through the `IAgentRuntime` interface, which provides:

### Agent Management

```typescript
// Create an agent
const agent = await runtime.createAgent(characterConfig);

// Get agent status
const status = agent.status;

// Update agent
await runtime.updateAgent(agent.id, {
  status: AgentStatus.ACTIVE,
  enabled: true
});
```

### Character Integration

The runtime uses the Character configuration to initialize agent behavior:

```typescript
const runtime = new AgentRuntime({
  character: characterConfig,
  // ... other runtime options
});

// Access character from runtime
const character = runtime.character;
console.log(character.name); // Agent name
console.log(character.bio); // Agent biography
```

## Practical Example

Here's a complete example of creating an agent with a character definition:

```typescript
import { AgentRuntime, AgentStatus } from '@elizaos/core';

// Define character
const character = {
  name: "Ada",
  username: "ada_assistant",
  bio: "A helpful AI assistant specializing in programming and mathematics",
  system: "You are Ada, a knowledgeable assistant. Be helpful and precise.",
  topics: ["programming", "mathematics", "computer science"],
  adjectives: ["helpful", "precise", "knowledgeable"],
  messageExamples: [
    [
      {
        name: "User",
        content: { text: "Can you help me with Python?" }
      },
      {
        name: "Ada",
        content: { text: "Of course! I'd be happy to help with Python. What specific question do you have?" }
      }
    ]
  ],
  style: {
    all: ["Be concise and helpful", "Use examples when explaining concepts"],
    chat: ["Keep responses conversational", "Ask follow-up questions"],
    post: ["Write in a professional tone", "Include relevant examples"]
  },
  plugins: ["plugin-bootstrap"]
};

// Create runtime with character
const runtime = new AgentRuntime({
  character,
  // ... other configuration
});

// The agent is now operational and can:
// - Process messages according to character personality
// - Use defined writing style
// - Access knowledge base
// - Execute actions through plugins
```

## Agent Lifecycle

### Creation
1. Character definition is validated
2. Agent record is created in database
3. Runtime is initialized with character config
4. Plugins are loaded based on character.plugins

### Operation
1. Agent receives messages
2. Character personality guides responses
3. Actions and evaluators process interactions
4. State is maintained between conversations

### Management
1. Status can be updated (ACTIVE/INACTIVE)
2. Character configuration can be modified
3. Plugins can be added or removed
4. Database records track changes

## Best Practices

### Character Design
- Keep bio concise but informative
- Provide diverse messageExamples
- Use specific adjectives for personality
- Include relevant topics for context

### Agent Configuration
- Set appropriate enabled/status flags
- Monitor agent performance
- Update character as needed
- Use proper error handling

### Runtime Integration
- Initialize runtime with complete character
- Handle agent state changes properly
- Implement proper cleanup on shutdown
- Monitor resource usage

## Common Patterns

### Multi-Agent Systems
```typescript
// Create multiple agents with different characters
const agents = await Promise.all([
  runtime.createAgent(supportCharacter),
  runtime.createAgent(salesCharacter),
  runtime.createAgent(technicalCharacter)
]);

// Route messages based on context
const routeToAgent = (message, context) => {
  if (context.type === 'support') return agents[0];
  if (context.type === 'sales') return agents[1];
  return agents[2]; // technical
};
```

### Dynamic Agent Updates
```typescript
// Update agent character based on user feedback
await runtime.updateAgent(agent.id, {
  ...agent,
  character: {
    ...agent.character,
    adjectives: [...agent.character.adjectives, "friendly"],
    topics: [...agent.character.topics, "customer service"]
  }
});
```

### Agent Health Monitoring
```typescript
// Check agent status
const checkAgentHealth = async (agent) => {
  return {
    enabled: agent.enabled,
    status: agent.status,
    lastUpdate: new Date(agent.updatedAt),
    isHealthy: agent.status === AgentStatus.ACTIVE && agent.enabled
  };
};
```

## Related Components

- **[Character Definition](./character-definition)**: Complete character schema and validation
- **[Actions](./actions)**: Agent action system for interactive behaviors
- **[Evaluators](./evaluators)**: Assessment and reflection systems
- **[Providers](./providers)**: Data and service integration
- **[Tasks](./tasks)**: Background task management

## Summary

Agents in ElizaOS combine static Character definitions with runtime operational state. They provide the foundation for autonomous AI entities that can interact naturally with users while maintaining consistent personalities and behaviors. The separation between Character and Agent allows for flexible deployment and management of AI agents in various contexts.