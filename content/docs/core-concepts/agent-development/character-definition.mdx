---
title: Character Definition
description: How to define and configure agent characters
---

# Character Definition

Character definitions are the blueprint for creating agents in elizaOS. They define an agent's personality, knowledge, behavioral patterns, and capabilities.

## Character Schema

Characters are validated using a strict Zod schema to ensure consistency and type safety:

```typescript
import { z } from 'zod';

// UUID validation schema
const uuidSchema = z
  .string()
  .regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, 'Invalid UUID format');

// Message content schema matching the Content interface
const contentSchema = z
  .object({
    text: z.string().optional(),
    thought: z.string().optional(),
    actions: z.array(z.string()).optional(),
    providers: z.array(z.string()).optional(),
    source: z.string().optional(),
    target: z.string().optional(),
    url: z.string().optional(),
    inReplyTo: uuidSchema.optional(),
    attachments: z.array(z.any()).optional(),
    channelType: z.string().optional(),
  })
  .passthrough(); // Allow additional properties

// MessageExample schema
const messageExampleSchema = z.object({
  name: z.string(),
  content: contentSchema,
});

// Knowledge item schema - can be string, object with path, or DirectoryItem
const knowledgeItemSchema = z.union([
  z.string(),
  z.object({
    path: z.string(),
    shared: z.boolean().optional(),
  }),
  z.object({
    directory: z.string(),
    shared: z.boolean().optional(),
  }),
]);

// Main Character schema
export const characterSchema = z
  .object({
    id: uuidSchema.optional(),
    name: z.string().min(1, 'Character name is required'),
    username: z.string().optional(),
    system: z.string().optional(),
    templates: z.record(z.union([z.string(), z.function().optional()])).optional(),
    bio: z.union([z.string(), z.array(z.string())]),
    messageExamples: z.array(z.array(messageExampleSchema)).optional(),
    postExamples: z.array(z.string()).optional(),
    topics: z.array(z.string()).optional(),
    adjectives: z.array(z.string()).optional(),
    knowledge: z.array(knowledgeItemSchema).optional(),
    plugins: z.array(z.string()).optional(),
    settings: z.record(z.union([z.string(), z.boolean(), z.number(), z.any()])).optional(),
    secrets: z.record(z.union([z.string(), z.boolean(), z.number()])).optional(),
    style: z
      .object({
        all: z.array(z.string()).optional(),
        chat: z.array(z.string()).optional(),
        post: z.array(z.string()).optional(),
      })
      .optional(),
  })
  .strict(); // Only allow known properties
```

## Core Properties

### Identity Fields

```typescript
const character: Character = {
  id: "550e8400-e29b-41d4-a716-446655440000", // Optional UUID
  name: "Alice",                                // Display name
  username: "alice_assistant"                   // Unique handle
};
```

### Biography and Personality

The bio can be a single string or array of strings:

```typescript
// Single bio string
bio: "A knowledgeable AI assistant specializing in scientific research and data analysis."

// Multi-line bio array
bio: [
  "Alice is a research-focused AI assistant with expertise in scientific domains.",
  "She has a particular interest in biology, chemistry, and data science.",
  "Alice values accuracy, clarity, and evidence-based reasoning."
]
```

### System Prompt

The system prompt defines core behavioral instructions:

```typescript
system: `You are Alice, a scientific research assistant. 
Your responses should be:
- Accurate and evidence-based
- Clear and well-structured
- Appropriately technical for the audience
- Honest about limitations and uncertainties

Always cite sources when making factual claims.`
```

## Message Examples

Message examples train the agent's conversational patterns. The content schema supports various fields:

```typescript
messageExamples: [
  // Example conversation 1
  [
    {
      name: "User",
      content: { 
        text: "What causes rain?" 
      }
    },
    {
      name: "Alice",
      content: { 
        text: "Rain occurs when water vapor in clouds condenses into droplets that become heavy enough to fall. This happens when warm, moist air rises and cools, or when air masses with different temperatures meet.",
        actions: ["EXPLAIN_SCIENTIFIC_CONCEPT"],
        thought: "The user is asking about a weather phenomenon. I should provide a clear, scientific explanation."
      }
    }
  ],
  // Example with attachments and metadata
  [
    {
      name: "User",
      content: { 
        text: "Can you analyze this data?",
        attachments: [{
          type: "file",
          url: "data.csv",
          contentType: "text/csv"
        }]
      }
    },
    {
      name: "Alice",
      content: { 
        text: "I'll analyze your CSV file. Let me process the data and identify key patterns.",
        actions: ["ANALYZE_DATA", "PROCESS_ATTACHMENT"],
        providers: ["dataAnalysisProvider"],
        source: "csv_analyzer"
      }
    }
  ]
]
```

### Content Schema Fields

- `text`: Main message content
- `thought`: Internal reasoning (not shown to user)
- `actions`: Actions to be executed
- `providers`: Providers to invoke
- `source`: Source system/module
- `target`: Target user/system
- `url`: Associated URL
- `inReplyTo`: UUID of message being replied to
- `attachments`: Media/file attachments
- `channelType`: Communication channel type

## Knowledge Configuration

Knowledge can be loaded from files or directories using three formats validated by the schema:

```typescript
knowledge: [
  // 1. Simple string path
  "./knowledge/science-basics.md",
  
  // 2. Object with path and optional shared flag
  {
    path: "./knowledge/research-methods.md",
    shared: true  // Available to all agents
  },
  
  // 3. DirectoryItem for loading entire directories
  {
    directory: "./knowledge/biology/",
    shared: false  // Agent-specific knowledge
  }
]
```

### Knowledge Loading

- **File paths**: Load individual markdown or text files
- **Directories**: Recursively load all files in a directory
- **Shared flag**: When `true`, knowledge is available across all agents
- **Formats supported**: Markdown (.md), text (.txt), and JSON (.json)

## Style Guidelines

Style arrays define writing patterns:

```typescript
style: {
  // Applied to all responses
  all: [
    "Use clear, concise language",
    "Prefer active voice",
    "Avoid jargon unless necessary"
  ],
  
  // Chat-specific style
  chat: [
    "Be conversational and friendly",
    "Use appropriate emojis sparingly",
    "Ask clarifying questions when needed"
  ],
  
  // Post-specific style
  post: [
    "Structure content with headers",
    "Include relevant examples",
    "End with a call-to-action or question"
  ]
}
```

## Topics and Adjectives

Define the agent's knowledge domains and personality traits:

```typescript
// Knowledge domains
topics: [
  "biology",
  "chemistry",
  "data science",
  "research methodology",
  "scientific writing"
],

// Personality traits
adjectives: [
  "analytical",
  "curious",
  "methodical",
  "helpful",
  "precise"
]
```

## Templates

Custom templates for various scenarios:

```typescript
templates: {
  // Static template (string)
  greetingTemplate: "Hello! I'm Alice, your research assistant. How can I help you today?",
  
  // Dynamic template (function) - Note: Functions are allowed at runtime but not in JSON
  analysisTemplate: ({ state }) => {
    const topic = state.currentTopic || "your research";
    return `Let me analyze ${topic} using scientific methods...`;
  },
  
  // Templates used by the system
  responseTemplate: "{{agentName}} thoughtfully considers the question about {{topic}}...",
  reflectionTemplate: "Upon reflection, I realize that {{observation}}..."
}
```

## Settings and Secrets

### Settings (Public Configuration)

```typescript
settings: {
  // Response configuration
  maxResponseLength: 500,
  temperature: 0.7,
  topP: 0.9,
  
  // Behavioral settings
  confidenceThreshold: 0.8,
  citationRequired: true,
  
  // Feature flags
  enableDataAnalysis: true,
  enableWebSearch: false,
  
  // Custom settings
  preferredCitationStyle: "APA",
  maxDatasetSize: 10000
}
```

### Secrets (Private Configuration)

```typescript
secrets: {
  // API keys and tokens
  RESEARCH_API_KEY: process.env.RESEARCH_API_KEY,
  DATABASE_TOKEN: process.env.DB_TOKEN,
  
  // Private configuration
  internalUserId: "alice-prod-001",
  maxTokenBudget: 1000000
}
```

## Character Validation

elizaOS provides comprehensive validation utilities in `@elizaos/core/schemas/character.ts`:

```typescript
import { validateCharacter, parseAndValidateCharacter, isValidCharacter } from '@elizaos/core';

// Validate character data
const result = validateCharacter(characterData);
if (result.success) {
  console.log('Valid character:', result.data);
} else {
  console.error('Validation errors:', result.error.issues);
}

// Parse and validate JSON string
const jsonResult = parseAndValidateCharacter(jsonString);
if (jsonResult.success) {
  console.log('Valid character from JSON:', jsonResult.data);
} else {
  console.error('JSON/Validation error:', jsonResult.error.message);
}

// Type guard for runtime checks
if (isValidCharacter(data)) {
  // TypeScript knows this is a valid Character
  const runtime = new AgentRuntime({ 
    character: data,
    plugins: [bootstrapPlugin]
  });
}
```

### Validation Result Type

```typescript
export interface CharacterValidationResult {
  success: boolean;
  data?: Character;
  error?: {
    message: string;
    issues?: z.ZodIssue[];
  };
}
```

## Example Characters

### Technical Support Agent

```typescript
const techSupport: Character = {
  name: "TechHelper",
  bio: "Your friendly technical support specialist",
  system: "You are a patient and knowledgeable tech support agent. Help users solve technical problems step-by-step.",
  
  topics: ["troubleshooting", "software", "hardware", "networking"],
  adjectives: ["patient", "clear", "systematic", "encouraging"],
  
  messageExamples: [
    [
      { name: "User", content: { text: "My computer won't start" } },
      { name: "TechHelper", content: { 
        text: "I'll help you troubleshoot this. First, let's check if it's getting power. Do you see any lights on the computer when you press the power button?",
        actions: ["TROUBLESHOOT"]
      }}
    ]
  ],
  
  style: {
    all: ["Use simple, non-technical language", "Break down steps clearly"],
    chat: ["Be encouraging and patient", "Confirm understanding"]
  },
  
  plugins: ["@elizaos/plugin-bootstrap", "@company/plugin-support-tools"],
  
  settings: {
    responseMode: "step-by-step",
    maxStepsPerResponse: 3,
    includeVisualAids: true
  }
};
```

### Creative Writing Assistant

```typescript
const creativeWriter: Character = {
  name: "Muse",
  bio: [
    "A creative writing assistant with a passion for storytelling",
    "Specializes in fiction, poetry, and creative non-fiction",
    "Loves exploring narrative techniques and literary devices"
  ],
  
  topics: ["creative writing", "storytelling", "poetry", "fiction", "literary analysis"],
  adjectives: ["imaginative", "articulate", "inspiring", "thoughtful"],
  
  templates: {
    storyPrompt: ({ state }) => 
      `What if ${state.character} discovered ${state.object} in ${state.setting}?`,
    
    poetryTemplate: "Let's explore the rhythm and imagery in your verse..."
  },
  
  style: {
    all: [
      "Use rich, descriptive language",
      "Include literary references when appropriate",
      "Encourage creative exploration"
    ],
    chat: [
      "Be enthusiastic about creative ideas",
      "Offer constructive feedback",
      "Suggest creative exercises"
    ]
  },
  
  settings: {
    creativeTemperature: 0.9,
    suggestionMode: "exploratory",
    genreKnowledge: ["fantasy", "sci-fi", "mystery", "literary"]
  }
};
```

## Best Practices

### 1. Consistency

- Ensure bio, examples, and style guidelines align with character personality
- Keep personality traits consistent across all properties
- Test character behavior against defined traits
- Validate JSON files using the schema before deployment
- Use the strict mode to catch unknown properties

### 2. Specificity

- Provide detailed, specific examples rather than generic ones
- Include edge cases in message examples
- Define clear boundaries in system prompts

### 3. Knowledge Management

- Organize knowledge files by topic
- Use shared knowledge for common information
- Keep sensitive data in secrets, not settings

### 4. Iterative Refinement

- Start with core personality traits and minimal configuration
- Add examples based on real interactions and edge cases
- Refine templates based on usage patterns and feedback
- Update knowledge files as the domain evolves
- Use validation tools to catch errors early
- Test with the bootstrap plugin before adding custom plugins

## Loading Characters

### From JSON Files

```typescript
import { parseAndValidateCharacter } from '@elizaos/core';
import { bootstrapPlugin } from '@elizaos/plugin-bootstrap';
import fs from 'fs';

// Load and validate character
const characterJson = fs.readFileSync('./characters/alice.json', 'utf-8');
const result = parseAndValidateCharacter(characterJson);

if (result.success) {
  const runtime = new AgentRuntime({ 
    character: result.data,
    plugins: [bootstrapPlugin],
    // Optional: add database adapter
    adapter: databaseAdapter
  });
} else {
  console.error('Character validation failed:', result.error);
  // Handle validation errors
  result.error.issues?.forEach(issue => {
    console.error(`- ${issue.path.join('.')}: ${issue.message}`);
  });
}
```

### From Environment

```typescript
// Load character based on environment
const characterName = process.env.CHARACTER_NAME || 'default';
const character = await loadCharacter(`./characters/${characterName}.json`);
```

## Next Steps

- Implement [Actions](/docs/core-concepts/agent-development/actions) for your character
- Add [Evaluators](/docs/core-concepts/agent-development/evaluators) for learning
- Configure [Providers](/docs/core-concepts/agent-development/providers) for context
- Set up [Tasks](/docs/core-concepts/agent-development/tasks) for automation