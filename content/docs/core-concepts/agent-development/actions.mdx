---
title: "Actions"
description: "Complete guide to implementing actions in ElizaOS, including the Action interface, handler patterns, validation, and real-world examples from plugin-bootstrap"
---

# Actions

Actions are the interactive behaviors that agents can perform in ElizaOS. They define how agents respond to different situations and execute specific tasks. This page covers the Action interface, implementation patterns, and practical examples from the plugin-bootstrap package.

## Action Interface

The Action interface defines the structure for all agent actions:

```typescript
interface Action {
  /** Similar action descriptions for context */
  similes?: string[];
  
  /** Detailed description of what the action does */
  description: string;
  
  /** Example usage scenarios */
  examples?: ActionExample[][];
  
  /** Core handler function that executes the action */
  handler: Handler;
  
  /** Action name/identifier */
  name: string;
  
  /** Validation function to determine if action should execute */
  validate: Validator;
}
```

### Core Components

#### Handler Function
The handler is the core execution logic:

```typescript
type Handler = (
  runtime: IAgentRuntime,
  message: Memory,
  state?: State,
  options?: { [key: string]: unknown },
  callback?: HandlerCallback,
  responses?: Memory[]
) => Promise<unknown>;
```

#### Validator Function
The validator determines if an action should execute:

```typescript
type Validator = (
  runtime: IAgentRuntime,
  message: Memory,
  state?: State
) => Promise<boolean>;
```

#### HandlerCallback
The callback processes action results:

```typescript
type HandlerCallback = (response: Content, files?: any) => Promise<Memory[]>;
```

#### ActionExample
Examples demonstrate action usage:

```typescript
interface ActionExample {
  /** User associated with the example */
  name: string;
  
  /** Content of the example */
  content: Content;
}
```

## Real-World Example: Reply Action

Let's examine the reply action from plugin-bootstrap:

```typescript
export const replyAction = {
  name: 'REPLY',
  similes: ['GREET', 'REPLY_TO_MESSAGE', 'SEND_REPLY', 'RESPOND', 'RESPONSE'],
  description: 'Replies to the current conversation with the text from the generated message. Default if the agent is responding with a message and no other action. Use REPLY at the beginning of a chain of actions as an acknowledgement, and at the end of a chain of actions as a final response.',
  
  validate: async (_runtime: IAgentRuntime) => {
    return true; // Always valid
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    _options: any,
    callback: HandlerCallback,
    responses?: Memory[]
  ) => {
    // Check if any responses had providers associated with them
    const allProviders = responses?.flatMap((res) => res.content?.providers ?? []) ?? [];

    // Only generate response using LLM if no suitable response was found
    state = await runtime.composeState(message, [...(allProviders ?? []), 'RECENT_MESSAGES']);

    const prompt = composePromptFromState({
      state,
      template: replyTemplate,
    });

    const response = await runtime.useModel(ModelType.OBJECT_LARGE, {
      prompt,
    });

    const responseContent = {
      thought: response.thought,
      text: (response.message as string) || '',
      actions: ['REPLY'],
    };

    await callback(responseContent);

    return true;
  },
  
  examples: [
    [
      {
        name: '{{name1}}',
        content: {
          text: 'Hello there!',
        },
      },
      {
        name: '{{name2}}',
        content: {
          text: 'Hi! How can I help you today?',
          actions: ['REPLY'],
        },
      },
    ],
    [
      {
        name: '{{name1}}',
        content: {
          text: "What's your favorite color?",
        },
      },
      {
        name: '{{name2}}',
        content: {
          text: 'I really like deep shades of blue. They remind me of the ocean and the night sky.',
          actions: ['REPLY'],
        },
      },
    ]
  ]
} as Action;
```

### Reply Template

The reply action uses a template for generating responses:

```typescript
const replyTemplate = `# Task: Generate dialog for the character {{agentName}}.
{{providers}}
# Instructions: Write the next message for {{agentName}}.
"thought" should be a short description of what the agent is thinking about and planning.
"message" should be the next message for {{agentName}} which they will send to the conversation.

Response format should be formatted in a valid JSON block like this:
\`\`\`json
{
    "thought": "<string>",
    "message": "<string>"
}
\`\`\`

Your response should include the valid JSON block and nothing else.`;
```

## Action Implementation Patterns

### Basic Action Structure

```typescript
export const myAction: Action = {
  name: 'MY_ACTION',
  description: 'Description of what this action does',
  
  validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Validation logic
    return true;
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback
  ) => {
    // Implementation logic
    const result = await performAction();
    
    if (callback) {
      await callback(result);
    }
    
    return result;
  },
  
  examples: [
    // Example interactions
  ]
};
```

### Validation Patterns

#### Simple Validation
```typescript
validate: async (runtime: IAgentRuntime, message: Memory) => {
  // Always execute
  return true;
}
```

#### Conditional Validation
```typescript
validate: async (runtime: IAgentRuntime, message: Memory) => {
  // Only execute if user mentions specific keyword
  return message.content.text?.includes('weather') || false;
}
```

#### State-Based Validation
```typescript
validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
  // Execute based on current state
  return state?.values?.userRole === 'admin';
}
```

#### Complex Validation
```typescript
validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
  // Multiple conditions
  const hasPermission = await checkUserPermission(message.entityId);
  const isInCorrectRoom = message.roomId === 'support-room';
  const isBusinessHours = new Date().getHours() >= 9 && new Date().getHours() <= 17;
  
  return hasPermission && isInCorrectRoom && isBusinessHours;
}
```

### Handler Patterns

#### Simple Response Handler
```typescript
handler: async (runtime, message, state, options, callback) => {
  const responseContent = {
    text: "Action executed successfully",
    actions: ['MY_ACTION']
  };
  
  await callback?.(responseContent);
  return true;
}
```

#### LLM-Based Handler
```typescript
handler: async (runtime, message, state, options, callback) => {
  const prompt = composePromptFromState({
    state,
    template: myTemplate
  });
  
  const response = await runtime.useModel(ModelType.OBJECT_LARGE, {
    prompt
  });
  
  const responseContent = {
    thought: response.thought,
    text: response.message,
    actions: ['MY_ACTION']
  };
  
  await callback?.(responseContent);
  return response;
}
```

#### Data Processing Handler
```typescript
handler: async (runtime, message, state, options, callback) => {
  // Process data
  const data = await fetchExternalData();
  const processedData = processData(data);
  
  // Update state
  await runtime.updateState(message.roomId, {
    lastUpdate: Date.now(),
    data: processedData
  });
  
  const responseContent = {
    text: `Processed ${processedData.length} items`,
    data: processedData,
    actions: ['MY_ACTION']
  };
  
  await callback?.(responseContent);
  return processedData;
}
```

## More Action Examples from Plugin-Bootstrap

### Send Message Action

```typescript
export const sendMessageAction = {
  name: 'SEND_MESSAGE',
  similes: ['MESSAGE', 'SEND', 'POST', 'PUBLISH'],
  description: 'Send a message to a specific room or user',
  
  validate: async (runtime: IAgentRuntime, message: Memory) => {
    // Check if user has permission to send messages
    return true;
  },
  
  handler: async (runtime, message, state, options, callback) => {
    const targetRoom = options?.roomId || message.roomId;
    const messageText = options?.text || state?.values?.messageText;
    
    if (!messageText) {
      throw new Error('No message text provided');
    }
    
    // Send message to target room
    await runtime.sendMessage(targetRoom, {
      text: messageText,
      entityId: runtime.agentId
    });
    
    const responseContent = {
      text: `Message sent to ${targetRoom}`,
      actions: ['SEND_MESSAGE']
    };
    
    await callback?.(responseContent);
    return true;
  },
  
  examples: [
    [
      {
        name: 'User',
        content: { text: 'Send a message to the general channel' }
      },
      {
        name: 'Agent',
        content: { 
          text: 'Message sent to general channel',
          actions: ['SEND_MESSAGE']
        }
      }
    ]
  ]
};
```

### Update Entity Action

```typescript
export const updateEntityAction = {
  name: 'UPDATE_ENTITY',
  similes: ['MODIFY', 'CHANGE', 'UPDATE', 'EDIT'],
  description: 'Update information about an entity',
  
  validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Check if there's an entity to update
    return !!state?.values?.entityId;
  },
  
  handler: async (runtime, message, state, options, callback) => {
    const entityId = options?.entityId || state?.values?.entityId;
    const updates = options?.updates || {};
    
    // Update entity in database
    await runtime.updateEntity(entityId, updates);
    
    const responseContent = {
      text: `Entity ${entityId} updated successfully`,
      actions: ['UPDATE_ENTITY']
    };
    
    await callback?.(responseContent);
    return true;
  },
  
  examples: [
    [
      {
        name: 'User',
        content: { text: 'Update user profile with new email' }
      },
      {
        name: 'Agent',
        content: { 
          text: 'User profile updated with new email address',
          actions: ['UPDATE_ENTITY']
        }
      }
    ]
  ]
};
```

### Settings Action

```typescript
export const updateSettingsAction = {
  name: 'UPDATE_SETTINGS',
  similes: ['CONFIGURE', 'SETTINGS', 'PREFERENCES', 'OPTIONS'],
  description: 'Update agent or system settings',
  
  validate: async (runtime: IAgentRuntime, message: Memory) => {
    // Check if user has admin privileges
    return message.content.text?.includes('settings') || false;
  },
  
  handler: async (runtime, message, state, options, callback) => {
    const settings = options?.settings || {};
    
    // Update settings
    await runtime.updateSettings(settings);
    
    const responseContent = {
      text: 'Settings updated successfully',
      actions: ['UPDATE_SETTINGS']
    };
    
    await callback?.(responseContent);
    return true;
  },
  
  examples: [
    [
      {
        name: 'User',
        content: { text: 'Update my notification settings' }
      },
      {
        name: 'Agent',
        content: { 
          text: 'Your notification settings have been updated',
          actions: ['UPDATE_SETTINGS']
        }
      }
    ]
  ]
};
```

## Advanced Action Patterns

### Chained Actions

Actions can be chained together for complex workflows:

```typescript
export const complexWorkflowAction = {
  name: 'COMPLEX_WORKFLOW',
  description: 'Execute a complex multi-step workflow',
  
  validate: async (runtime, message) => {
    return message.content.text?.includes('start workflow') || false;
  },
  
  handler: async (runtime, message, state, options, callback) => {
    const steps = [
      'VALIDATE_INPUT',
      'PROCESS_DATA',
      'SEND_NOTIFICATION',
      'UPDATE_RECORDS'
    ];
    
    let results = [];
    
    for (const step of steps) {
      const action = runtime.getAction(step);
      if (action) {
        const result = await action.handler(runtime, message, state, options, callback);
        results.push(result);
      }
    }
    
    const responseContent = {
      text: `Workflow completed with ${results.length} steps`,
      actions: ['COMPLEX_WORKFLOW']
    };
    
    await callback?.(responseContent);
    return results;
  },
  
  examples: [
    [
      {
        name: 'User',
        content: { text: 'Start workflow for new customer' }
      },
      {
        name: 'Agent',
        content: { 
          text: 'Workflow initiated for new customer processing',
          actions: ['COMPLEX_WORKFLOW']
        }
      }
    ]
  ]
};
```

### Conditional Actions

Actions that execute different logic based on conditions:

```typescript
export const conditionalAction = {
  name: 'CONDITIONAL_ACTION',
  description: 'Execute different logic based on user type',
  
  validate: async (runtime, message) => {
    return true;
  },
  
  handler: async (runtime, message, state, options, callback) => {
    const userType = state?.values?.userType || 'guest';
    
    let responseContent;
    
    switch (userType) {
      case 'admin':
        responseContent = {
          text: 'Admin features enabled',
          actions: ['CONDITIONAL_ACTION', 'ADMIN_FEATURES']
        };
        break;
        
      case 'premium':
        responseContent = {
          text: 'Premium features available',
          actions: ['CONDITIONAL_ACTION', 'PREMIUM_FEATURES']
        };
        break;
        
      default:
        responseContent = {
          text: 'Basic features available',
          actions: ['CONDITIONAL_ACTION', 'BASIC_FEATURES']
        };
    }
    
    await callback?.(responseContent);
    return responseContent;
  },
  
  examples: [
    [
      {
        name: 'Admin',
        content: { text: 'What can I do?' }
      },
      {
        name: 'Agent',
        content: { 
          text: 'Admin features enabled - you have full access',
          actions: ['CONDITIONAL_ACTION']
        }
      }
    ]
  ]
};
```

## Best Practices

### Action Design

1. **Single Responsibility**: Each action should have a clear, single purpose
2. **Clear Naming**: Use descriptive names that indicate the action's function
3. **Good Validation**: Implement proper validation to prevent unnecessary execution
4. **Error Handling**: Handle errors gracefully and provide meaningful feedback

### Validation Guidelines

```typescript
// Good: Specific validation
validate: async (runtime, message) => {
  return message.content.text?.toLowerCase().includes('weather') || false;
}

// Better: Comprehensive validation
validate: async (runtime, message, state) => {
  const hasWeatherKeyword = message.content.text?.toLowerCase().includes('weather');
  const hasLocation = state?.values?.location;
  const hasApiKey = runtime.getSetting('weather_api_key');
  
  return hasWeatherKeyword && hasLocation && hasApiKey;
}
```

### Handler Implementation

```typescript
// Good: Error handling
handler: async (runtime, message, state, options, callback) => {
  try {
    const result = await performAction();
    
    const responseContent = {
      text: 'Action completed successfully',
      data: result,
      actions: ['MY_ACTION']
    };
    
    await callback?.(responseContent);
    return result;
  } catch (error) {
    const errorContent = {
      text: `Action failed: ${error.message}`,
      actions: ['ERROR']
    };
    
    await callback?.(errorContent);
    throw error;
  }
}
```

### Example Quality

```typescript
// Good: Comprehensive examples
examples: [
  // Simple case
  [
    {
      name: 'User',
      content: { text: 'What is the weather?' }
    },
    {
      name: 'Agent',
      content: { 
        text: 'The weather is sunny and 72°F',
        actions: ['WEATHER']
      }
    }
  ],
  
  // Complex case
  [
    {
      name: 'User',
      content: { text: 'What is the weather forecast for tomorrow in New York?' }
    },
    {
      name: 'Agent',
      content: { 
        text: 'Tomorrow in New York: Partly cloudy with a high of 68°F and low of 55°F',
        actions: ['WEATHER']
      }
    }
  ]
]
```

## Testing Actions

### Unit Testing

```typescript
describe('replyAction', () => {
  it('should validate correctly', async () => {
    const runtime = mockRuntime();
    const message = mockMessage();
    
    const isValid = await replyAction.validate(runtime, message);
    expect(isValid).toBe(true);
  });
  
  it('should handle message properly', async () => {
    const runtime = mockRuntime();
    const message = mockMessage();
    const state = mockState();
    const callback = jest.fn();
    
    await replyAction.handler(runtime, message, state, {}, callback);
    
    expect(callback).toHaveBeenCalledWith(
      expect.objectContaining({
        text: expect.any(String),
        actions: ['REPLY']
      })
    );
  });
});
```

### Integration Testing

```typescript
describe('Action Integration', () => {
  it('should work with runtime', async () => {
    const runtime = new AgentRuntime({
      character: mockCharacter(),
      // ... other config
    });
    
    runtime.registerAction(myAction);
    
    const message = await runtime.processMessage(mockMessage());
    expect(message.content.actions).toContain('MY_ACTION');
  });
});
```

## Common Pitfalls

### Validation Issues

```typescript
// Bad: Overly broad validation
validate: async () => true

// Bad: No error handling
validate: async (runtime, message) => {
  return message.content.text.includes('keyword'); // Can throw if text is null
}

// Good: Proper validation
validate: async (runtime, message) => {
  return message.content.text?.includes('keyword') || false;
}
```

### Handler Problems

```typescript
// Bad: No error handling
handler: async (runtime, message, state, options, callback) => {
  const data = await fetchData(); // Can throw
  await callback({ text: data.result });
}

// Good: Proper error handling
handler: async (runtime, message, state, options, callback) => {
  try {
    const data = await fetchData();
    await callback({ text: data.result, actions: ['MY_ACTION'] });
  } catch (error) {
    await callback({ text: 'Failed to fetch data', actions: ['ERROR'] });
    throw error;
  }
}
```

## Related Components

- **[Agents](./agents)**: How actions are executed within agent runtime
- **[Evaluators](./evaluators)**: Assessment systems that complement actions
- **[Providers](./providers)**: Data sources for action context
- **[Character Definition](./character-definition)**: How character traits influence actions

## Summary

Actions are the executable behaviors that give agents their interactive capabilities. They combine validation logic, handler implementation, and examples to create robust, reusable components. The plugin-bootstrap package provides excellent examples of real-world action implementations that demonstrate best practices for validation, error handling, and user interaction patterns. Well-designed actions form the foundation of engaging agent behaviors in ElizaOS.