---
title: Actions
description: Creating and implementing agent actions
---

# Actions

Actions are executable functions that agents can perform in response to messages. They represent the agent's ability to interact with the world beyond just generating text responses.

## Action Interface

Every action implements the following interface from `@elizaos/core/src/types/components.ts`:

```typescript
/**
 * Represents an action the agent can perform
 */
export interface Action {
  /** Similar action descriptions */
  similes?: string[];
  
  /** Detailed description */
  description: string;
  
  /** Example usages */
  examples?: ActionExample[][];
  
  /** Handler function */
  handler: Handler;
  
  /** Action name */
  name: string;
  
  /** Validation function */
  validate: Validator;
}

// Supporting types
export interface ActionExample {
  /** User associated with the example */
  name: string;
  
  /** Content of the example */
  content: Content;
}

export type Handler = (
  runtime: IAgentRuntime,
  message: Memory,
  state?: State,
  options?: { [key: string]: unknown },
  callback?: HandlerCallback,
  responses?: Memory[]
) => Promise<unknown>;

export type Validator = (
  runtime: IAgentRuntime,
  message: Memory,
  state?: State
) => Promise<boolean>;

export type HandlerCallback = (
  response: Content,
  files?: any
) => Promise<Memory[]>;
```

## Creating Actions

### Basic Action Structure

Here's how to create a custom action following the pattern from the bootstrap plugin:

```typescript
import {
  type Action,
  type ActionExample,
  type HandlerCallback,
  type IAgentRuntime,
  type Memory,
  type State,
} from '@elizaos/core';

export const greetAction: Action = {
  name: 'GREET',
  similes: ['SAY_HELLO', 'WELCOME', 'INTRODUCE'],
  description: 'Greets a user or entity in a friendly manner',
  
  validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Check if this is a greeting context
    const keywords = ['hello', 'hi', 'hey', 'greetings', 'welcome'];
    const text = message.content.text?.toLowerCase() || '';
    return keywords.some(keyword => text.includes(keyword));
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback,
    responses?: Memory[]
  ) => {
    // Access user information from state
    const userName = state?.values?.userName || 'friend';
    
    // Create the response content
    const response = {
      text: `Hello ${userName}! It's great to meet you. How can I help you today?`,
      actions: ['GREET'],
      metadata: {
        greeted: true,
        timestamp: Date.now()
      }
    };
    
    // Call the callback to send the response
    if (callback) {
      await callback(response);
    }
    
    // Return success
    return true;
  },
  
  examples: [
    [
      {
        name: '{{name1}}',
        content: { text: 'Hello there!' }
      },
      {
        name: '{{name2}}',
        content: {
          text: 'Hello friend! It\'s great to meet you. How can I help you today?',
          actions: ['GREET']
        }
      }
    ]
  ] as ActionExample[][]
};
```

### Complex Action Example

Here's a more complex action that interacts with external systems:

```typescript
export const searchDocumentAction: Action = {
  name: 'SEARCH_DOCUMENTS',
  similes: ['FIND_DOCS', 'SEARCH_FILES', 'LOOKUP_DOCUMENTS'],
  description: 'Searches through a document database for relevant information',
  
  validate: async (runtime: IAgentRuntime, message: Memory) => {
    // Check if message requests document search
    const searchPatterns = [
      /search.*document/i,
      /find.*file/i,
      /look.*up/i,
      /where.*is/i
    ];
    
    const text = message.content.text || '';
    return searchPatterns.some(pattern => pattern.test(text));
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback
  ) => {
    try {
      // Extract search query from message
      const query = extractSearchQuery(message.content.text);
      
      // Access external service
      const searchService = runtime.getService('documentSearch');
      const results = await searchService.search({
        query,
        limit: options?.limit || 5,
        filters: options?.filters
      });
      
      // Format results
      const formattedResults = results.map(doc => 
        `- ${doc.title}: ${doc.summary}`
      ).join('\n');
      
      const response = {
        text: `I found ${results.length} documents matching your search:\n\n${formattedResults}`,
        actions: ['SEARCH_DOCUMENTS'],
        attachments: results.map(doc => ({
          type: 'document',
          id: doc.id,
          title: doc.title,
          url: doc.url
        }))
      };
      
      // Store search in conversation memory
      await runtime.createMemory({
        entityId: message.entityId,
        content: {
          text: `Searched for: ${query}`,
          metadata: { resultCount: results.length }
        },
        roomId: message.roomId
      });
      
      if (callback) {
        await callback(response);
      }
      
      return { success: true, results };
      
    } catch (error) {
      runtime.logger.error('Document search failed:', error);
      
      const errorResponse = {
        text: 'I encountered an error while searching. Please try again.',
        actions: ['SEARCH_DOCUMENTS'],
        error: true
      };
      
      if (callback) {
        await callback(errorResponse);
      }
      
      return { success: false, error: error.message };
    }
  },
  
  examples: [
    [
      {
        name: 'User',
        content: { text: 'Can you search for documents about machine learning?' }
      },
      {
        name: 'Assistant',
        content: {
          text: 'I found 3 documents matching your search:\n\n- Introduction to ML: A comprehensive guide...\n- Deep Learning Basics: Fundamental concepts...\n- ML Best Practices: Industry standards...',
          actions: ['SEARCH_DOCUMENTS']
        }
      }
    ]
  ]
};
```

## Action Validation

The `validate` function determines whether an action should be available:

```typescript
validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
  // Check permissions
  const hasPermission = await runtime.checkPermission(
    message.entityId,
    'documents.read'
  );
  
  if (!hasPermission) {
    return false;
  }
  
  // Check context
  const isRelevant = state?.values?.context === 'document_management';
  
  // Check message content
  const requestsSearch = /search|find|lookup/i.test(message.content.text || '');
  
  return isRelevant && requestsSearch;
}
```

## Action Handlers

Handlers execute the action logic:

```typescript
handler: async (
  runtime: IAgentRuntime,
  message: Memory,
  state?: State,
  options?: any,
  callback?: HandlerCallback
) => {
  // 1. Prepare action
  const context = await runtime.composeState(message);
  
  // 2. Execute action logic
  const result = await performAction(context);
  
  // 3. Generate response
  const response = {
    text: formatResponse(result),
    actions: [actionName],
    metadata: result.metadata
  };
  
  // 4. Call callback if provided
  if (callback) {
    await callback(response);
  }
  
  // 5. Return result
  return result;
}
```

## Action Examples

Examples train the AI on when and how to use actions:

```typescript
examples: [
  // Example 1: Basic usage
  [
    {
      name: '{{name1}}',
      content: { text: 'Set a reminder for tomorrow at 3pm' }
    },
    {
      name: '{{name2}}',
      content: {
        text: 'I\'ve set a reminder for tomorrow at 3:00 PM.',
        actions: ['SET_REMINDER']
      }
    }
  ],
  
  // Example 2: With clarification
  [
    {
      name: '{{name1}}',
      content: { text: 'Remind me about the meeting' }
    },
    {
      name: '{{name2}}',
      content: {
        text: 'When would you like me to remind you about the meeting?',
        actions: ['REQUEST_CLARIFICATION']
      }
    },
    {
      name: '{{name1}}',
      content: { text: 'In 2 hours' }
    },
    {
      name: '{{name2}}',
      content: {
        text: 'Perfect! I\'ll remind you about the meeting in 2 hours.',
        actions: ['SET_REMINDER']
      }
    }
  ]
]
```

## Built-in Actions from plugin-bootstrap

The bootstrap plugin provides several essential actions:

### REPLY Action

The default response mechanism from `@elizaos/plugin-bootstrap/src/actions/reply.ts`:

```typescript
export const replyAction = {
  name: 'REPLY',
  similes: ['GREET', 'REPLY_TO_MESSAGE', 'SEND_REPLY', 'RESPOND', 'RESPONSE'],
  description:
    'Replies to the current conversation with the text from the generated message. ' +
    'Default if the agent is responding with a message and no other action. ' +
    'Use REPLY at the beginning of a chain of actions as an acknowledgement, ' +
    'and at the end of a chain of actions as a final response.',
  
  validate: async (_runtime: IAgentRuntime) => {
    return true; // Always valid as default action
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    _options: any,
    callback: HandlerCallback,
    responses?: Memory[]
  ) => {
    // Compose state with recent messages and any providers from responses
    const allProviders = responses?.flatMap((res) => 
      res.content?.providers ?? []
    ) ?? [];
    
    state = await runtime.composeState(message, [
      ...(allProviders ?? []),
      'RECENT_MESSAGES'
    ]);
    
    // Generate response using the reply template
    const prompt = composePromptFromState({
      state,
      template: replyTemplate,
    });
    
    const response = await runtime.useModel(ModelType.OBJECT_LARGE, {
      prompt,
    });
    
    const responseContent = {
      thought: response.thought,
      text: (response.message as string) || '',
      actions: ['REPLY'],
    };
    
    await callback(responseContent);
    return true;
  },
  
  examples: [
    [
      {
        name: '{{name1}}',
        content: { text: 'Hello there!' },
      },
      {
        name: '{{name2}}',
        content: {
          text: 'Hi! How can I help you today?',
          actions: ['REPLY'],
        },
      },
    ],
    // ... more examples
  ] as ActionExample[][],
} as Action;
```

### NONE Action

Explicitly takes no action:

```typescript
import { noneAction } from '@elizaos/plugin-bootstrap';

// Used when the agent should acknowledge but not respond
// Useful for ending conversations or acknowledging statements
```

### CHOICE Action

Presents options to the user:

```typescript
import { choiceAction } from '@elizaos/plugin-bootstrap';

// Presents multiple options for the user to choose from
// Useful for guided interactions and decision trees
```

### Other Bootstrap Actions

- **followRoom/unfollowRoom**: Manage room subscriptions
- **muteRoom/unmuteRoom**: Control room notifications
- **ignore**: Ignore specific messages or users
- **sendMessage**: Send messages to specific rooms
- **updateEntity**: Update entity information
- **settings**: Manage agent settings
- **roles**: Manage user roles and permissions

## Registering Actions

### In Plugins

```typescript
import { Plugin } from '@elizaos/core';

export const myPlugin: Plugin = {
  name: 'my-plugin',
  description: 'Custom actions for my domain',
  
  actions: [
    greetAction,
    searchDocumentAction,
    customAction
  ],
  
  register: async (runtime: IAgentRuntime) => {
    // Actions are automatically registered
    runtime.logger.info('Custom actions registered');
  }
};
```

### Direct Registration

```typescript
// Register individual actions
runtime.registerAction(myCustomAction);

// Register multiple actions
const actions = [action1, action2, action3];
actions.forEach(action => runtime.registerAction(action));
```

## Action Composition

Actions can be chained or composed:

```typescript
export const compositeAction: Action = {
  name: 'ANALYZE_AND_SUMMARIZE',
  
  handler: async (runtime, message, state, options, callback) => {
    // Step 1: Analyze content
    const analysis = await runtime.executeAction('ANALYZE_CONTENT', {
      message,
      state
    });
    
    // Step 2: Generate summary based on analysis
    const summary = await runtime.executeAction('GENERATE_SUMMARY', {
      message,
      state: {
        ...state,
        values: {
          ...state?.values,
          analysis: analysis.result
        }
      }
    });
    
    // Step 3: Format and return combined result
    const response = {
      text: `Analysis complete. ${summary.result}`,
      actions: ['ANALYZE_AND_SUMMARIZE'],
      metadata: {
        analysis,
        summary
      }
    };
    
    if (callback) {
      await callback(response);
    }
    
    return response;
  }
};
```

## Error Handling

Proper error handling is crucial:

```typescript
handler: async (runtime, message, state, options, callback) => {
  try {
    // Validate inputs
    if (!message.content.text) {
      throw new Error('No text content provided');
    }
    
    // Execute action with timeout
    const result = await Promise.race([
      performAction(message),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Action timeout')), 30000)
      )
    ]);
    
    // Handle success
    return { success: true, result };
    
  } catch (error) {
    // Log error with context
    runtime.logger.error('Action failed', {
      action: 'MY_ACTION',
      messageId: message.id,
      error: error.message
    });
    
    // Return error response
    const errorResponse = {
      text: 'I encountered an issue processing your request.',
      actions: ['ERROR'],
      error: true,
      metadata: {
        errorType: error.name,
        errorMessage: error.message
      }
    };
    
    if (callback) {
      await callback(errorResponse);
    }
    
    return { success: false, error: error.message };
  }
}
```

## Best Practices

### 1. Clear Naming

- Use descriptive, action-oriented names
- Maintain consistent naming conventions
- Provide meaningful similes

### 2. Validation Logic

- Keep validation fast and efficient
- Check permissions and context
- Return false early when not applicable

### 3. Handler Implementation

- Always handle errors gracefully
- Provide meaningful responses via callback
- Return structured data for downstream processing
- Clean up resources in finally blocks

### 4. Examples

- Provide diverse, realistic examples
- Cover edge cases and error scenarios
- Use template variables like `{{name1}}`, `{{name2}}`, etc.
- Show multi-turn interactions when relevant

### 5. Testing

```typescript
import { testAction } from '@elizaos/core/testing';

describe('MyAction', () => {
  it('should validate correctly', async () => {
    const result = await testAction(myAction, {
      message: { content: { text: 'test message' } },
      expectedValidation: true,
      expectedResponse: { actions: ['MY_ACTION'] }
    });
    
    expect(result.validated).toBe(true);
    expect(result.response.actions).toContain('MY_ACTION');
  });
});
```

## Next Steps

- Learn about [Evaluators](/docs/core-concepts/agent-development/evaluators) for response assessment
- Explore [Providers](/docs/core-concepts/agent-development/providers) for supplying context
- Understand [Tasks](/docs/core-concepts/agent-development/tasks) for scheduled actions