---
title: "Runtime Architecture"
description: "Deep dive into the AgentRuntime class and its lifecycle management"
---

# Runtime Architecture

The ElizaOS runtime architecture is built around the `AgentRuntime` class, which serves as the core orchestrator for all agent operations. This system provides a flexible, event-driven framework that manages plugins, services, models, and agent lifecycle.

## Core Components

### AgentRuntime Class

The `AgentRuntime` class implements the `IAgentRuntime` interface and serves as the primary execution environment for agents:

```typescript
export class AgentRuntime implements IAgentRuntime {
  readonly agentId: UUID;
  readonly character: Character;
  public adapter!: IDatabaseAdapter;
  readonly actions: Action[] = [];
  readonly evaluators: Evaluator[] = [];
  readonly providers: Provider[] = [];
  readonly plugins: Plugin[] = [];
  private isInitialized = false;
  // ... additional properties
}
```

### Key Properties

- **agentId**: Unique identifier for the agent instance
- **character**: The agent's personality and configuration
- **adapter**: Database adapter for persistent storage
- **actions**: Registered actions the agent can perform
- **evaluators**: Components that evaluate messages and responses
- **providers**: Data providers for context and state
- **plugins**: Loaded plugins extending agent functionality

## Runtime Lifecycle

### 1. Initialization

The runtime follows a structured initialization process:

```typescript
async initialize(): Promise<void> {
  if (this.isInitialized) {
    this.logger.warn('Agent already initialized');
    return;
  }

  // Register all plugins
  const pluginRegistrationPromises = [];
  for (const plugin of this.characterPlugins) {
    if (plugin) {
      pluginRegistrationPromises.push(this.registerPlugin(plugin));
    }
  }
  await Promise.all(pluginRegistrationPromises);

  // Initialize database adapter
  await this.adapter.init();

  // Run plugin migrations
  await this.runPluginMigrations();

  // Create agent entity
  const existingAgent = await this.ensureAgentExists(this.character);
  
  // Setup room and participants
  await this.setupRoomAndParticipants();

  this.isInitialized = true;
}
```

### 2. Plugin Registration

Each plugin is registered through a comprehensive process:

```typescript
async registerPlugin(plugin: Plugin): Promise<void> {
  // Validate plugin
  if (!plugin?.name) {
    throw new Error('Plugin or plugin name is undefined');
  }

  // Check for duplicates
  const existingPlugin = this.plugins.find((p) => p.name === plugin.name);
  if (existingPlugin) {
    this.logger.warn(`Plugin ${plugin.name} already registered`);
    return;
  }

  // Add to active plugins
  this.plugins.push(plugin);

  // Initialize plugin
  if (plugin.init) {
    await plugin.init(plugin.config || {}, this);
  }

  // Register plugin components
  if (plugin.actions) {
    plugin.actions.forEach(action => this.registerAction(action));
  }
  if (plugin.evaluators) {
    plugin.evaluators.forEach(evaluator => this.registerEvaluator(evaluator));
  }
  if (plugin.providers) {
    plugin.providers.forEach(provider => this.registerProvider(provider));
  }
  if (plugin.services) {
    plugin.services.forEach(service => this.registerService(service));
  }
}
```

### 3. Service Management

Services are managed through a type-safe system:

```typescript
async registerService(serviceDef: typeof Service): Promise<void> {
  const serviceType = serviceDef.serviceType as ServiceTypeName;
  
  if (this.services.has(serviceType)) {
    this.logger.warn(`Service ${serviceType} already registered`);
    return;
  }

  const serviceInstance = await serviceDef.start(this);
  this.services.set(serviceType, serviceInstance);
  this.serviceTypes.set(serviceType, serviceDef);
}

getService<T extends Service = Service>(serviceName: ServiceTypeName): T | null {
  return this.services.get(serviceName) as T | null;
}
```

## Memory and State Management

### State Composition

The runtime composes state from multiple providers:

```typescript
async composeState(
  message: Memory,
  includeList: string[] | null = null,
  onlyInclude = false,
  skipCache = false
): Promise<State> {
  const cachedState = skipCache ? {} : await this.stateCache.get(message.id);
  
  // Determine which providers to use
  const providerNames = new Set<string>();
  if (includeList) {
    includeList.forEach(name => providerNames.add(name));
  } else {
    this.providers
      .filter(p => !p.private && !p.dynamic)
      .forEach(p => providerNames.add(p.name));
  }

  // Get provider data
  const providerData = await Promise.all(
    providersToGet.map(async (provider) => {
      const result = await provider.get(this, message, cachedState);
      return { ...result, providerName: provider.name };
    })
  );

  // Aggregate state
  const newState = {
    values: aggregatedStateValues,
    data: { providers: currentProviderResults },
    text: providersText,
  };

  this.stateCache.set(message.id, newState);
  return newState;
}
```

### Memory Management

The runtime provides comprehensive memory operations:

```typescript
async createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID> {
  // Add embedding if not present
  if (!memory.embedding) {
    memory = await this.addEmbeddingToMemory(memory);
  }
  
  return await this.adapter.createMemory(memory, tableName, unique);
}

async searchMemories(params: {
  embedding: number[];
  query?: string;
  match_threshold?: number;
  count?: number;
  roomId?: UUID;
  tableName: string;
}): Promise<Memory[]> {
  const memories = await this.adapter.searchMemories(params);
  
  // Re-rank results if query provided
  if (params.query) {
    return await this.rerankMemories(params.query, memories);
  }
  
  return memories;
}
```

## Model Management

### Model Registration

Models are registered with priority-based selection:

```typescript
registerModel(
  modelType: ModelTypeName,
  handler: (params: any) => Promise<any>,
  provider: string,
  priority?: number
) {
  const modelKey = typeof modelType === 'string' ? modelType : ModelType[modelType];
  
  if (!this.models.has(modelKey)) {
    this.models.set(modelKey, []);
  }

  this.models.get(modelKey)?.push({
    handler,
    provider,
    priority: priority || 0,
    registrationOrder: Date.now(),
  });

  // Sort by priority then registration order
  this.models.get(modelKey)?.sort((a, b) => {
    if ((b.priority || 0) !== (a.priority || 0)) {
      return (b.priority || 0) - (a.priority || 0);
    }
    return a.registrationOrder - b.registrationOrder;
  });
}
```

### Model Usage

Models are used through a unified interface:

```typescript
async useModel<T extends ModelTypeName, R = ModelResultMap[T]>(
  modelType: T,
  params: Omit<ModelParamsMap[T], 'runtime'> | any,
  provider?: string
): Promise<R> {
  const model = this.getModel(modelType, provider);
  if (!model) {
    throw new Error(`No handler found for model type: ${modelType}`);
  }

  const startTime = performance.now();
  const response = await model(this, { ...params, runtime: this });
  const elapsedTime = performance.now() - startTime;

  // Log model usage
  await this.adapter.log({
    entityId: this.agentId,
    roomId: this.agentId,
    body: {
      modelType,
      params,
      response,
      executionTime: elapsedTime,
    },
    type: `useModel:${modelType}`,
  });

  return response as R;
}
```

## Action Processing

### Action Execution

Actions are processed through a structured pipeline:

```typescript
async processActions(
  message: Memory,
  responses: Memory[],
  state?: State,
  callback?: HandlerCallback
): Promise<void> {
  for (const response of responses) {
    const actions = response.content.actions;
    
    for (const responseAction of actions) {
      // Find matching action
      const action = this.findAction(responseAction);
      
      if (action && action.handler) {
        // Track action execution
        const actionId = uuidv4() as UUID;
        this.currentActionContext = {
          actionName: action.name,
          actionId,
          prompts: [],
        };

        try {
          await action.handler(this, message, state, {}, callback, responses);
          
          // Log action execution
          await this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: 'action',
            body: {
              action: action.name,
              actionId,
              message: message.content.text,
              prompts: this.currentActionContext.prompts,
            },
          });
        } finally {
          this.currentActionContext = undefined;
        }
      }
    }
  }
}
```

## Event System

### Event Registration and Emission

The runtime supports a flexible event system:

```typescript
registerEvent(event: string, handler: (params: any) => Promise<void>) {
  if (!this.events.has(event)) {
    this.events.set(event, []);
  }
  this.events.get(event)?.push(handler);
}

async emitEvent(event: string | string[], params: any) {
  const events = Array.isArray(event) ? event : [event];
  
  for (const eventName of events) {
    const eventHandlers = this.events.get(eventName);
    if (eventHandlers) {
      await Promise.all(eventHandlers.map(handler => handler(params)));
    }
  }
}
```

## Connection Management

### Entity and Room Management

The runtime manages connections between entities and rooms:

```typescript
async ensureConnection({
  entityId,
  roomId,
  worldId,
  // ... other params
}: ConnectionParams) {
  // Create entity if not exists
  const entity = await this.getEntityById(entityId);
  if (!entity) {
    await this.createEntity({
      id: entityId,
      names: [name, userName].filter(Boolean),
      metadata: entityMetadata,
      agentId: this.agentId,
    });
  }

  // Ensure world exists
  await this.ensureWorldExists({
    id: worldId,
    name: worldName,
    agentId: this.agentId,
  });

  // Ensure room exists
  await this.ensureRoomExists({
    id: roomId,
    worldId,
    // ... other room params
  });

  // Add participant to room
  await this.ensureParticipantInRoom(entityId, roomId);
}
```

## Shutdown and Cleanup

### Graceful Shutdown

The runtime provides mechanisms for graceful shutdown:

```typescript
async stop() {
  this.logger.debug(`Stopping runtime for character ${this.character.name}`);
  
  // Stop all services
  for (const [serviceName, service] of this.services) {
    this.logger.debug(`Stopping service ${serviceName}`);
    await service.stop();
  }

  // Close database connection
  if (this.adapter) {
    await this.adapter.close();
  }
}
```

## Best Practices

### 1. Resource Management

- Always initialize the runtime before using it
- Properly handle plugin initialization failures
- Use connection pooling for database operations
- Implement proper cleanup in service stop methods

### 2. Error Handling

- Wrap plugin operations in try-catch blocks
- Log errors with appropriate context
- Use graceful degradation for non-critical failures
- Implement retry mechanisms for transient failures

### 3. Performance Optimization

- Use state caching to avoid redundant provider calls
- Implement lazy loading for expensive operations
- Monitor memory usage and implement cleanup
- Use connection pooling for database operations

### 4. Testing

- Mock the runtime interface for unit tests
- Use test databases for integration tests
- Implement proper setup and teardown
- Test plugin registration and lifecycle

The runtime architecture provides a robust foundation for building intelligent agents with extensible functionality through the plugin system while maintaining performance and reliability.